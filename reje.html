<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Wind</title>
    <style>
        /* Estilos CSS */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            user-select: none;
            touch-action: manipulation;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        h1 {
            font-size: 16px; 
            margin: 10px 0;
        }

        #game-container {
            border: 3px solid #333;
            position: relative;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
            margin-top: 10px;
            max-width: 400px; 
            width: 95%; 
            aspect-ratio: 4 / 6;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background-color: #87ceeb; 
            display: block;
            position: relative; 
            z-index: 1; 
        }

        /* Ajustes de estilo para el score y el botón en pantalla pequeña */
        #score {
            position: absolute;
            top: 5px; 
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px; 
            color: #333;
            font-weight: bold;
            padding: 3px 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            z-index: 10; 
            text-align: center;
            border: 2px solid #333;
        }
        
        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px; 
            font-size: 18px; 
            font-family: 'Press Start 2P', cursive;
            background-color: #4CAF50; 
            color: white;
            border: 3px solid #388E3C; 
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 6px #2E7D32; 
            transition: all 0.05s;
            z-index: 20; 
        }

        #start-button:active {
            box-shadow: 0 3px #2E7D32;
            transform: translate(-50%, -48%) scale(0.98);
        }
    </style>
</head>
<body>

    <h1> Flappy Wind</h1>

    <div id="game-container">
        <div id="score">SCORE: 0</div>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <button id="start-button">PLAY</button>
    </div>

    <script>
        // Lógica JavaScript
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        
        // --- CONSTANTES DE REFERENCIA ORIGINALES (400x600) ---
        const BASE_WIDTH = 400; 
        const BASE_HEIGHT = 600;
        const BASE_GRAVITY = 0.3; 
        const FIXED_JUMP_FORCE = -6; 
        const BASE_INITIAL_PIPE_SPEED = 3;  
        const BASE_SPEED_INCREASE = 0.2;
        const BASE_PIPE_WIDTH = 50; 
        const BASE_PIPE_GAP = 160;
        
        const BASE_COLLISION_RADIUS = 12; // Radio de COLISIÓN (más pequeño)
        const BASE_DRAW_RADIUS = 15;      // Radio VISUAL original (15)
        
        const BASE_BALL_X = 50;
        const BASE_FONT_TITLE = 30;
        const BASE_FONT_SCORE = 16;
        const PIPE_SPAWN_RATE = 1600;

        // --- CONSTANTES para la Flecha Indicadora
        const ARROW_SIZE = 30; // Tamaño de la flecha (Aumentado ligeramente para visibilidad)
        const ARROW_OFFSET_X = 35; // Distancia desde el borde derecho
        const ARROW_COLOR = '#FFD700'; // Color amarillo brillante
        const ARROW_LINE_WIDTH = 4; // Grosor de línea
        // ---------------------------------------------------

        // --- Cargar la imagen del PLAYER (viento.png) y de Colisión (colision.png) ---
        
        const playerImage = new Image();
        playerImage.src = 'viento.png'; 
        
        const collisionImage = new Image();
        collisionImage.src = 'colision.png'; 
        
        let imagesLoaded = false; 
        let pipeImageAspectRatio = 1; 
        let playerImageAspectRatio = 1; 
        
        let playerImageLoaded = false;
        let collisionImageLoaded = false;

        function checkAllImagesLoaded() {
            if (playerImageLoaded && collisionImageLoaded) {
                imagesLoaded = true;
                if (!isGameRunning && isGameOver) {
                    showStartScreen(); 
                }
            }
        }

        playerImage.onload = () => {
            playerImageLoaded = true;
            playerImageAspectRatio = playerImage.width / playerImage.height; 
            checkAllImagesLoaded();
        };
        playerImage.onerror = () => {
            console.error("Error al cargar la imagen 'viento.png'. Asegúrate de que esté en la carpeta correcta.");
        };

        collisionImage.onload = () => {
            collisionImageLoaded = true;
            pipeImageAspectRatio = collisionImage.width / collisionImage.height; 
            checkAllImagesLoaded();
        };

        collisionImage.onerror = () => {
            console.error("Error al cargar la imagen 'colision.png'. Asegúrate de que esté en la carpeta correcta.");
        };


        // --- Variables de Juego Escaladas ---
        let scaleFactor = 1; 
        let currentPipeSpeed; 
        let GRAVITY;
        let PIPE_WIDTH;
        let PIPE_GAP;
        let ballRadius;
        let drawRadius; 
        
        let ball = {
            x: 50,
            y: canvas.height / 2,
            radius: 15, 
            dy: 0 
        };

        let pipes = []; 
        let lastPipeTime = 0;
        let score = 0;
        let isGameOver = true;
        let isGameRunning = false;
        let animationFrameId;

        // --- NUEVAS VARIABLES para la Flecha Indicadora
        let nextPipeCenterY = canvas.height / 2; // Centro Y del próximo hueco
        let currentArrowSize; 
        let currentArrowOffsetX; 
        // ----------------------------------------------------

        // --- FUNCIONES DE ESCALADO ---

        function getScaledValue(baseValue) {
            return baseValue * scaleFactor;
        }

        function adjustGameScale() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            scaleFactor = canvas.width / BASE_WIDTH;
            
            GRAVITY = getScaledValue(BASE_GRAVITY); 
            
            PIPE_WIDTH = getScaledValue(BASE_PIPE_WIDTH);
            PIPE_GAP = getScaledValue(BASE_PIPE_GAP);
            
            ballRadius = getScaledValue(BASE_COLLISION_RADIUS); 
            drawRadius = getScaledValue(BASE_DRAW_RADIUS); 

            ball.x = getScaledValue(BASE_BALL_X);
            ball.y = canvas.height / 2;
            ball.radius = ballRadius; 

            currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED + (score * BASE_SPEED_INCREASE));
            
            // ESCALADO de la flecha
            currentArrowSize = getScaledValue(ARROW_SIZE);
            currentArrowOffsetX = getScaledValue(ARROW_OFFSET_X);
            
            if (!isGameRunning) {
                showStartScreen(); 
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            GRAVITY = getScaledValue(BASE_GRAVITY);
            adjustGameScale();
        });
        window.addEventListener('resize', adjustGameScale);
        

        function drawBall() {
            const imageHeight = drawRadius * 2; 
            const imageWidth = imageHeight * playerImageAspectRatio; 
            
            const drawX = ball.x - (imageWidth / 2);
            const drawY = ball.y - (imageHeight / 2);

            if (playerImageLoaded) {
                ctx.drawImage(playerImage, drawX, drawY, imageWidth, imageHeight);
            } else {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, drawRadius, 0, Math.PI * 2); 
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.strokeStyle = '#800'; 
                ctx.lineWidth = getScaledValue(2);
                ctx.stroke();
                ctx.closePath();
            }
        }

        function drawPipe(pipe) {
            if (!imagesLoaded) {
                ctx.fillStyle = 'blue';
                ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.strokeStyle = '#004';
                ctx.lineWidth = getScaledValue(3);
                ctx.strokeRect(pipe.x, pipe.y, pipe.width, pipe.height);
                return;
            }

            const imageHeight = pipe.height;
            const imageWidth = imageHeight * pipeImageAspectRatio; 
            
            const pipeCenterX = pipe.x + pipe.width / 2;
            const drawX = pipeCenterX - imageWidth / 2;

            ctx.save(); 

            if (pipe.isTop) {
                const visualCenterY = pipe.y + imageHeight / 2;
                ctx.translate(0, visualCenterY); 
                ctx.scale(1, -1); 
                ctx.drawImage(collisionImage, drawX, -visualCenterY, imageWidth, imageHeight);
            } else {
                ctx.drawImage(collisionImage, drawX, pipe.y, imageWidth, imageHeight);
            }

            ctx.restore(); 
        }

        // --- FUNCIÓN MEJORADA: Dibujar la flecha indicadora
        function drawArrow() {
            if (!isGameRunning || isGameOver) return; 

            // 1. Encontrar el centro Y del hueco del próximo pipe
            let closestPipeHoleCenter = null;
            let minDistance = Infinity;

            // Busca el primer pipe que no ha sido pasado por el jugador
            for (let i = 0; i < pipes.length; i++) {
                const p = pipes[i];
                // Solo consideramos el pipe superior o inferior del par
                if (p.x + p.width > ball.x) {
                    const pipePairIndex = p.isTop ? i : i - 1;
                    
                    if (pipes[pipePairIndex] && pipes[pipePairIndex + 1] && pipes[pipePairIndex].x === pipes[pipePairIndex + 1].x) {
                         const topPipeHeight = pipes[pipePairIndex].height;
                         const holeTopY = topPipeHeight;
                         const holeBottomY = topPipeHeight + PIPE_GAP;
                         
                         const holeCenter = (holeTopY + holeBottomY) / 2;
                         
                         const distance = pipes[pipePairIndex].x - ball.x;
                         if (distance < minDistance) {
                            minDistance = distance;
                            closestPipeHoleCenter = holeCenter;
                            // Salimos del loop una vez que encontramos el más cercano que no se ha pasado
                            break; 
                         }
                    }
                }
            }

            // 2. Si hay un pipe, dibuja la flecha apuntando a la altura del hueco
            if (closestPipeHoleCenter !== null) {
                ctx.save();
                ctx.strokeStyle = ARROW_COLOR;
                ctx.lineWidth = getScaledValue(ARROW_LINE_WIDTH);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const arrowX = canvas.width - currentArrowOffsetX; 
                const targetY = closestPipeHoleCenter; // La flecha debe aparecer a la altura del hueco
                const halfSize = currentArrowSize / 2;

                ctx.translate(arrowX, targetY); // Mover el origen a la posición del centro del hueco
                
                // Dibujar la flecha centrada en la altura del hueco (targetY)
                ctx.beginPath();

                // Línea vertical que indica la posición del hueco
                ctx.moveTo(0, -halfSize);
                ctx.lineTo(0, halfSize);

                // Punta de la flecha hacia el centro de la pantalla (izquierda)
                ctx.moveTo(0, 0);
                ctx.lineTo(-halfSize * 0.75, -halfSize / 2);
                ctx.moveTo(0, 0);
                ctx.lineTo(-halfSize * 0.75, halfSize / 2);

                ctx.stroke();
                ctx.restore();
            }
        }
        // ----------------------------------------------------------------------------------

        function updateBall() {
            ball.dy += GRAVITY; 
            ball.y += ball.dy;

            if (ball.y + ball.radius >= canvas.height) { 
                ball.y = canvas.height - ball.radius;
                gameOver();
            }
            if (ball.y - ball.radius < 0) { 
                ball.y = ball.radius;
                ball.dy = 0;
            }
        }

        function updatePipes() {
            for (let i = pipes.length - 1; i >= 0; i--) {
                let p = pipes[i];
                p.x -= currentPipeSpeed; 

                if (checkCollision(ball, p)) { 
                    gameOver();
                    return; 
                }

                if (!p.scored && p.x + p.width < ball.x) {
                    score++;
                    p.scored = true;
                    scoreDisplay.textContent = `SCORE: ${score}`;
                    currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED + (score * BASE_SPEED_INCREASE));
                }

                if (p.x + p.width < 0) {
                    pipes.splice(i, 1);
                }
            }

            if (performance.now() - lastPipeTime > PIPE_SPAWN_RATE) {
                createPipe();
                lastPipeTime = performance.now();
            }
        }

        function createPipe() {
            const minHeight = getScaledValue(80);
            const maxHeight = canvas.height - PIPE_GAP - minHeight;
            // Almacenamos la altura superior del pipe para usarla en el cálculo del centro del hueco
            const topHeight = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight; 
            
            pipes.push({ x: canvas.width, y: 0, width: PIPE_WIDTH, height: topHeight, scored: false, isTop: true });
            pipes.push({ x: canvas.width, y: topHeight + PIPE_GAP, width: PIPE_WIDTH, height: canvas.height - topHeight - PIPE_GAP, scored: false, isTop: false });
        }

        function checkCollision(circle, rect) {
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let distX = circle.x - closestX;
            let distY = circle.y - closestY;

            let distance = Math.sqrt((distX * distX) + (distY * distY));
            return distance < circle.radius; 
        }

        function jump() {
            if (!isGameRunning) {
                startGame();
            }
            if (isGameRunning && !isGameOver) {
                ball.dy = getScaledValue(FIXED_JUMP_FORCE); 
            } else if (isGameOver) {
                startGame();
            }
        }
        
        function startGame() {
            if (!imagesLoaded || (isGameRunning && !isGameOver)) return; 

            isGameRunning = true;
            startButton.style.display = 'none';
            resetGame(); 
        }

        function gameOver() {
            if (isGameOver) return;
            isGameOver = true;
            isGameRunning = false;
            cancelAnimationFrame(animationFrameId);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const fontSizeTitle = Math.floor(getScaledValue(BASE_FONT_TITLE));
            const fontSizeScore = Math.floor(getScaledValue(BASE_FONT_SCORE));
            
            ctx.font = `${fontSizeTitle}px "Press Start 2P"`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('¡You died!', canvas.width / 2, canvas.height / 2 - getScaledValue(40));

            ctx.font = `${fontSizeScore}px "Press Start 2P"`;
            ctx.fillText(`Puntos: ${score}`, canvas.width / 2, canvas.height / 2);
            
            startButton.textContent = 'RETRY?';
            startButton.style.backgroundColor = '#FF9800'; 
            startButton.style.borderColor = '#E65100';
            startButton.style.display = 'block';
        }

        function resetGame() {
            currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED); 
            
            ball.y = canvas.height / 2;
            ball.dy = 0;
            pipes = [];
            score = 0;
            scoreDisplay.textContent = `SCORE: 0`;
            isGameOver = false;
            lastPipeTime = performance.now();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            gameLoop();
        }

        // --- Loop Principal (Game Loop) ---

        function gameLoop() {
            if (!isGameRunning || isGameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updateBall();
            updatePipes();

            drawBall();
            pipes.forEach(drawPipe);
            drawArrow(); // Llamada a la función mejorada

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Inicialización y Eventos ---
        
        function showStartScreen() {
            if (!imagesLoaded) return; 

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBall(); 
            
            startButton.textContent = 'PLAY!';
            startButton.style.backgroundColor = '#4CAF50';
            startButton.style.borderColor = '#388E3C';
            startButton.style.display = 'block'; 
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            jump();
        });
        canvas.addEventListener('click', jump);
        startButton.addEventListener('click', startGame); 
        
        if (imagesLoaded) {
            showStartScreen();
        }
    </script>

</body>
</html>
