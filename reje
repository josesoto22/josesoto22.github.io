<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Wind</title>
    <style>
        /* Estilos CSS */
        body {
            display: flex;
            flex-direction: column;
            /* CAMBIO: Usamos flex-start en lugar de center para que el título se vea bien en móvil */
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            user-select: none;
            /* Añadido para mejor experiencia táctil en móvil */
            touch-action: manipulation;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* Ajuste de título para que no sea muy grande en móvil */
        h1 {
            font-size: 16px; 
            margin: 10px 0;
        }

        #game-container {
            border: 3px solid #333;
            position: relative;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
            margin-top: 10px; /* Reducir margen superior en móvil */
            /* 2. CAMBIOS CLAVE: Ajuste de tamaño responsive para el contenedor */
            max-width: 400px; /* Tamaño máximo en PC */
            width: 95%; /* Ocupa el 95% del ancho de la pantalla en móvil */
            aspect-ratio: 4 / 6; /* Mantiene la proporción 400x600 */
        }

        #gameCanvas {
            /* 3. CAMBIO CLAVE: El canvas ocupa el 100% de su contenedor */
            width: 100%;
            height: 100%;
            background-color: #87ceeb; 
            display: block;
            position: relative; 
            z-index: 1; 
        }

        /* Ajustes de estilo para el score y el botón en pantalla pequeña */
        #score {
            position: absolute;
            top: 5px; /* Pequeño ajuste */
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px; /* Reducir fuente */
            color: #333;
            font-weight: bold;
            padding: 3px 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            z-index: 10; 
            text-align: center;
            border: 2px solid #333;
        }
        
        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px; /* Reducir padding */
            font-size: 18px; /* Reducir fuente */
            font-family: 'Press Start 2P', cursive;
            background-color: #4CAF50; 
            color: white;
            border: 3px solid #388E3C; /* Reducir borde */
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 6px #2E7D32; /* Reducir sombra */
            transition: all 0.05s;
            z-index: 20; 
        }

        #start-button:active {
            box-shadow: 0 3px #2E7D32;
            transform: translate(-50%, -48%) scale(0.98);
        }
    </style>
</head>
<body>

    <h1> Flappy Wind</h1>

    <div id="game-container">
        <div id="score">Puntuación: 0</div>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <button id="start-button">INICIAR JUEGO</button>
    </div>

    <script>
        // Lógica JavaScript
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        
        // --- 4. CONSTANTES DE REFERENCIA ---
        const BASE_WIDTH = 400; 
        const BASE_HEIGHT = 600;
        const BASE_GRAVITY = 0.3;     
        const BASE_JUMP_FORCE = -6;
        const BASE_INITIAL_PIPE_SPEED = 3;  
        const BASE_SPEED_INCREASE = 0.3;
        const BASE_PIPE_WIDTH = 50; 
        const BASE_PIPE_GAP = 160;
        const BASE_BALL_RADIUS = 15;
        const BASE_BALL_X = 50;
        const BASE_FONT_TITLE = 30;
        const BASE_FONT_SCORE = 16;


        // --- Cargar la imagen de Colisión ---
        const collisionImage = new Image();
        collisionImage.src = 'colision.png'; 
        let imagesLoaded = false; 
        let imageAspectRatio = 1; 

        collisionImage.onload = () => {
            imagesLoaded = true;
            imageAspectRatio = collisionImage.width / collisionImage.height; 
            if (!isGameRunning && isGameOver) {
                showStartScreen(); 
            }
        };

        collisionImage.onerror = () => {
            console.error("Error al cargar la imagen 'colision.png'. Asegúrate de que esté en la carpeta correcta.");
        };


        // --- Variables de Juego Escalandes ---
        let scaleFactor = 1; 
        let currentPipeSpeed; 
        let GRAVITY;
        let JUMP_FORCE;
        let PIPE_WIDTH; 
        let PIPE_GAP;
        let ballRadius;
        
        let ball = {
            x: 50,
            y: canvas.height / 2,
            radius: 15,
            dy: 0 
        };

        let pipes = []; 
        let lastPipeTime = 0;
        let score = 0;
        let isGameOver = true;
        let isGameRunning = false;
        let animationFrameId;

        const PIPE_SPAWN_RATE = 1600; // El tiempo no se escala

        // --- 5. FUNCIONES DE ESCALADO ---

        function getScaledValue(baseValue) {
            return baseValue * scaleFactor;
        }

        function adjustGameScale() {
            const container = document.getElementById('game-container');
            // Sincroniza la resolución interna del canvas con su tamaño real de CSS
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Calcula el factor de escala
            scaleFactor = canvas.width / BASE_WIDTH;
            
            // Recalcula todas las CONSTANTES de FÍSICA y TAMAÑO
            GRAVITY = getScaledValue(BASE_GRAVITY);
            JUMP_FORCE = getScaledValue(BASE_JUMP_FORCE);
            PIPE_WIDTH = getScaledValue(BASE_PIPE_WIDTH);
            PIPE_GAP = getScaledValue(BASE_PIPE_GAP);
            ballRadius = getScaledValue(BASE_BALL_RADIUS);

            // Ajusta la posición de la bola
            ball.x = getScaledValue(BASE_BALL_X);
            ball.y = canvas.height / 2;
            ball.radius = ballRadius;

            // Ajusta la velocidad de los pipes
            currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED + (score * BASE_SPEED_INCREASE));
            
            // Si no está corriendo, redibuja la pantalla de inicio con el nuevo tamaño
            if (!isGameRunning) {
                 showStartScreen(); 
            }
        }
        
        // Ejecución inicial y listener de resize
        document.addEventListener('DOMContentLoaded', () => {
             // Forzar el ajuste inicial para que la bola y el juego se vean bien al cargar
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            adjustGameScale();
        });
        window.addEventListener('resize', adjustGameScale);
        

        // Dibuja la bola roja (Usa variables escaladas: ball.x, ball.y, ball.radius)
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.strokeStyle = '#800'; 
            ctx.lineWidth = getScaledValue(2); // Escalar el grosor de la línea
            ctx.stroke();
            ctx.closePath();
        }

        // --- Dibuja el pipe (Usa getScaledValue para el ancho de línea) ---
        function drawPipe(pipe) {
            if (!imagesLoaded) {
                ctx.fillStyle = 'blue';
                ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.strokeStyle = '#004';
                ctx.lineWidth = getScaledValue(3); // Escalar el grosor de la línea
                ctx.strokeRect(pipe.x, pipe.y, pipe.width, pipe.height);
                return;
            }

            const imageHeight = pipe.height;
            const imageWidth = imageHeight * imageAspectRatio; 
            
            const pipeCenterX = pipe.x + pipe.width / 2;
            const drawX = pipeCenterX - imageWidth / 2;

            ctx.save(); 

            if (pipe.isTop) {
                const visualCenterY = pipe.y + imageHeight / 2;
                ctx.translate(0, visualCenterY); 
                ctx.scale(1, -1); 
                ctx.drawImage(collisionImage, drawX, -visualCenterY, imageWidth, imageHeight);
            } else {
                ctx.drawImage(collisionImage, drawX, pipe.y, imageWidth, imageHeight);
            }

            ctx.restore(); 
        }

        // --- Lógica de juego: Usa variables escaladas (GRAVITY, ball.radius) ---

        function updateBall() {
            ball.dy += GRAVITY;
            ball.y += ball.dy;

            if (ball.y + ball.radius >= canvas.height) {
                ball.y = canvas.height - ball.radius;
                gameOver();
            }
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.dy = 0;
            }
        }

        function updatePipes() {
            for (let i = pipes.length - 1; i >= 0; i--) {
                let p = pipes[i];
                p.x -= currentPipeSpeed; 

                if (checkCollision(ball, p)) {
                    gameOver();
                    return; 
                }

                if (!p.scored && p.x + p.width < ball.x) {
                    score++;
                    p.scored = true;
                    scoreDisplay.textContent = `Puntuación: ${score}`;
                    // La velocidad actual se ajusta usando la función escalada
                    currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED + (score * BASE_SPEED_INCREASE));
                }

                if (p.x + p.width < 0) {
                    pipes.splice(i, 1);
                }
            }

            if (performance.now() - lastPipeTime > PIPE_SPAWN_RATE) {
                createPipe();
                lastPipeTime = performance.now();
            }
        }

        // createPipe: Usa PIPE_WIDTH y PIPE_GAP (escalados)
        function createPipe() {
            const minHeight = getScaledValue(80);
            const maxHeight = canvas.height - PIPE_GAP - minHeight;
            const topHeight = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight;
             
            pipes.push({ x: canvas.width, y: 0, width: PIPE_WIDTH, height: topHeight, scored: false, isTop: true });
            pipes.push({ x: canvas.width, y: topHeight + PIPE_GAP, width: PIPE_WIDTH, height: canvas.height - topHeight - PIPE_GAP, scored: false, isTop: false });
        }

        function checkCollision(circle, rect) {
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let distX = circle.x - closestX;
            let distY = circle.y - closestY;

            let distance = Math.sqrt((distX * distX) + (distY * distY));
            return distance < circle.radius;
        }

        function jump() {
            if (!isGameRunning) {
                startGame();
            }
            if (isGameRunning && !isGameOver) {
                ball.dy = JUMP_FORCE; // Usa la fuerza de salto ESCALADA
            } else if (isGameOver) {
                startGame();
            }
        }
         
        function startGame() {
            if (!imagesLoaded || (isGameRunning && !isGameOver)) return; 

            isGameRunning = true;
            startButton.style.display = 'none';
            resetGame(); 
        }

        // gameOver: Usa getScaledValue para el tamaño de la fuente
        function gameOver() {
            if (isGameOver) return;
            isGameOver = true;
            isGameRunning = false;
            cancelAnimationFrame(animationFrameId);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Escalar fuentes y posiciones
            const fontSizeTitle = Math.floor(getScaledValue(BASE_FONT_TITLE));
            const fontSizeScore = Math.floor(getScaledValue(BASE_FONT_SCORE));
            
            ctx.font = `${fontSizeTitle}px "Press Start 2P"`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('¡FIN!', canvas.width / 2, canvas.height / 2 - getScaledValue(40));

            ctx.font = `${fontSizeScore}px "Press Start 2P"`;
            ctx.fillText(`Puntos: ${score}`, canvas.width / 2, canvas.height / 2);
             
            startButton.textContent = 'REINTENTAR';
            startButton.style.backgroundColor = '#FF9800'; 
            startButton.style.borderColor = '#E65100';
            startButton.style.display = 'block';
        }

        function resetGame() {
            // Usa valores iniciales ESCALADOS
            currentPipeSpeed = getScaledValue(BASE_INITIAL_PIPE_SPEED); 
             
            ball.y = canvas.height / 2;
            ball.dy = 0;
            pipes = [];
            score = 0;
            scoreDisplay.textContent = `Puntuación: 0`;
            isGameOver = false;
            lastPipeTime = performance.now();
             
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            gameLoop();
        }

        // --- Loop Principal (Game Loop) ---

        function gameLoop() {
            if (!isGameRunning || isGameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updateBall();
            updatePipes();

            drawBall();
            pipes.forEach(drawPipe);

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Inicialización y Eventos ---
         
        function showStartScreen() {
            if (!imagesLoaded) return; 

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBall(); 
             
            startButton.textContent = 'INICIAR JUEGO';
            startButton.style.backgroundColor = '#4CAF50';
            startButton.style.borderColor = '#388E3C';
            startButton.style.display = 'block'; 
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        });
        // Añadido evento touchstart para móviles
        canvas.addEventListener('touchstart', jump);
        canvas.addEventListener('click', jump);
        startButton.addEventListener('click', startGame); 
         
        if (imagesLoaded) {
            showStartScreen();
        }
    </script>

</body>
</html>
